// Package grpctransport implements the ConnectRPC gRPC server
// that handles file transfer requests and interacts with storage.
package grpctransport

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gilwong00/file-streamer/internal/gen/proto/v1/transferv1connect"
	"github.com/gilwong00/file-streamer/internal/pkg/config"
	"github.com/gilwong00/file-streamer/internal/pkg/storage"
	"github.com/gilwong00/file-streamer/internal/server/transport/grpc/transferservice"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
)

// connectRPCServer implements the TransferServiceHandler interface
// and hosts the ConnectRPC server to handle gRPC file transfer requests.
//
// It embeds the autogenerated UnimplementedTransferServiceHandler to
// forward unimplemented methods with default behaviors.
type connectRPCServer struct {
	transferv1connect.UnimplementedTransferServiceHandler
	ctx           context.Context
	address       string
	storageClient *storage.Client
}

// NewConnectRPCServer creates and returns a new ConnectRPC server instance.
//
// It initializes the storage client from the given config and binds
// the server to the configured port.
func NewConnectRPCServer(ctx context.Context, config *config.Config) (*connectRPCServer, error) {
	storageClient, err := storage.NewStorageClient(
		config.MinioHost,
		config.MinioAccessKeyID,
		config.MinioAccessKey,
		config.MinioUseSSL,
	)
	if err != nil {
		return nil, err
	}
	return &connectRPCServer{
		ctx:           ctx,
		address:       fmt.Sprintf(":%v", 5555),
		storageClient: &storageClient,
	}, nil
}

// StartServer launches the ConnectRPC server and begins listening for incoming requests.
//
// It sets up HTTP handlers with HTTP/2 cleartext (h2c) support to allow gRPC
// communication without TLS, typically for local or internal use.
//
// The server runs in a separate goroutine, and this method blocks until either:
//   - The server encounters a fatal error during startup or runtime, which is returned.
//   - The server's context is canceled, triggering a graceful shutdown.
//
// The shutdown process waits up to 10 seconds for active connections to close.
func (s *connectRPCServer) StartServer() error {
	mux := http.NewServeMux()
	transferService := transferservice.NewTransferService(s.storageClient)
	transferPath, transferHandler := transferv1connect.NewTransferServiceHandler(transferService)
	mux.Handle(transferPath, transferHandler)
	srv := &http.Server{
		Addr:    s.address,
		Handler: h2c.NewHandler(mux, &http2.Server{}),
	}
	errChan := make(chan error, 1)
	go func() {
		log.Printf("ConnectRPC server listening on %s", s.address)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			errChan <- fmt.Errorf("listen failed: %w", err)
		}
	}()
	// Wait for cancellation signal on the context.
	<-s.ctx.Done()
	log.Printf("ConnectRPC server shutting down")
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	// Attempt graceful shutdown within timeout.
	if err := srv.Shutdown(shutdownCtx); err != nil {
		return fmt.Errorf("server shutdown error: %w", err)
	}
	// Return any listen error received.
	select {
	case err := <-errChan:
		return err
	default:
		return nil
	}
}
